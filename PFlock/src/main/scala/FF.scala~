import org.slf4j.{Logger, LoggerFactory}
import org.apache.spark.sql.functions._
import org.apache.spark.sql.simba.SimbaSession
import org.apache.spark.sql.simba.index.RTreeType
import org.apache.spark.sql.catalyst.ScalaReflection
import org.apache.spark.sql.types.StructType

object FF{
  private val logger: Logger = LoggerFactory.getLogger("myLogger")
  private val ST_Point_schema = ScalaReflection.schemaFor[ST_Point].dataType.asInstanceOf[StructType]
  case class ST_Point(pid: Int, x: Double, y: Double, t: Double)
  
  def main(args: Array[String]) {
    val conf       = new ConfFF(args)
    val input      = conf.input()
    val debug      = conf.debug()
    val master     = conf.master()
    val partitions = conf.partitions()
    val cores      = conf.cores()

    logger.info("Logs started")

    // Starting session...
    var timer = System.currentTimeMillis()
    val simba = SimbaSession.builder().master(master).appName("FF")
      .config("simba.index.partitions", partitions)
      .config("spark.cores.max", cores)
      .getOrCreate()
    import simba.implicits._
    import simba.simbaImplicits._
    log("Session started", timer)

    // Indexing points...
    timer = System.currentTimeMillis()
    val points = simba.read.option("delimiter", "\t").option("header", "false").schema(ST_Point_schema).csv(input).as[ST_Point]
      .index(RTreeType, "pointsRT", Array("x", "y", "t")).cache()
    val nPoints = points.count()
    log("Points indexed", timer, nPoints, "points")
    if(debug) points.show(truncate = false)

    // Computing the grid...
    timer = System.currentTimeMillis()
    val bounds = points.agg(min($"x").as("min_x"), max($"x").as("max_x"), min($"y").as("min_y"), max($"y").as("max_y"), min($"t").as("min_t"), max($"t").as("max_t")).collect().map(s => (s.getDouble(0),s.getDouble(1),s.getDouble(2),s.getDouble(3),s.getDouble(4),s.getDouble(5))).head
    if(debug) logger.info(s"Bounds: ${bounds}")
    val cell_centroids = (bounds._1 to bounds._2 by conf.grain_x()).toList.cross((bounds._3 to bounds._4 by conf.grain_y()).toList).cross((bounds._5 to bounds._6 by conf.grain_t()).toList).toList.zipWithIndex
    val grid = simba.createDataset(cell_centroids).map(g => ST_Point(g._2, g._1._1._1, g._1._1._2, g._1._2)).cache()
    val nGrid = grid.count()
    if(debug) grid.orderBy($"pid").show(truncate=false)
    log("Grid computed", timer, nGrid, "cells")

    // Joining points and grid...
    //timer = System.currentTimeMillis()
    //val pointsByGrid = points.toDF("gid","gx","gy","gt").knnJoin(grid, Array("gx","gy","gt"), Array("x","y","t"), 1).map(p => (p.getInt(4), ST_Point(p.getInt(0),p.getDouble(1),p.getDouble(2),p.getDouble(3))))
    //val nPointsByGrid = pointsByGrid.count()
    //if(debug) pointsByGrid.show(truncate=false)
    //pointsByGrid.rdd.partitionBy(new GridPartitioner(nGrid)).map(_._2).toDS().show(truncate=false)
    //log("Points by grid done", timer)

    // Stopping session...
    simba.stop()
    logger.info("Session closed")
  }

  def log(msg: String, timer: Long, n: Long = 0, tag: String = ""): Unit ={
    if(n == 0)
      logger.info("%-50s|%6.2f".format(msg,(System.currentTimeMillis()-timer)/1000.0))
    else
      logger.info("%-50s|%6.2f|%6d|%s".format(msg,(System.currentTimeMillis()-timer)/1000.0,n,tag))
  }

  implicit class Crossable[X](xs: Traversable[X]) {
    def cross[Y](ys: Traversable[Y]) = for { x <- xs; y <- ys } yield (x, y)
  }

  import org.apache.spark.Partitioner

  class GridPartitioner(partitions: Int) extends Partitioner{
    override def numPartitions: Int = partitions

    override def getPartition(key: Any): Int = {
      key.asInstanceOf[Int]
    }
  }

}

import org.rogach.scallop.{ScallopConf, ScallopOption}

class ConfFF(args: Seq[String]) extends ScallopConf(args) {
  val input:   ScallopOption[String]   =  opt[String]   (required = true)
  val master:  ScallopOption[String]   =  opt[String]   (default = Some("spark://169.235.27.134:7077"))
  val partitions: ScallopOption[Int]   =  opt[Int]      (default = Some(128))
  val cores:   ScallopOption[Int]      =  opt[Int]      (default = Some(21))
  val grain_x: ScallopOption[Double]   =  opt[Double]   (default = Some(10000.0))
  val grain_y: ScallopOption[Double]   =  opt[Double]   (default = Some(10000.0))
  val grain_t: ScallopOption[Double]   =  opt[Double]   (default = Some(3.0))
  val debug:   ScallopOption[Boolean]  =  opt[Boolean]  (default = Some(false))

  verify()
}
